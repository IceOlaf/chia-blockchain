(mod
  (
    INNER_PUZZLE
    SINGLETON_HASHES_TO_CURRY  ; Should be curried all the way except INNER_PUZZLE
    METADATA_LAYER_HASHES  ; Should be curried all the way up to METADATA
    VALUES_TO_PROVE
    proofs_of_inclusion
    new_metadatas  ; (root . etc)
    new_metadata_updaters
    new_inner_puzs
    inner_solution
  )

  (include condition_codes.clvm)
  (include merkle_utils.clib)
  (include curry-and-treehash.clinc)

  (defmacro assert items
      (if (r items)
          (list if (f items) (c assert (r items)) (q . (x)))
          (f items)
      )
  )

  ; takes a lisp tree and returns the hash of it
  (defun sha256tree1 (TREE)
        (if (l TREE)
            (sha256 2 (sha256tree1 (f TREE)) (sha256tree1 (r TREE)))
            (sha256 ONE TREE)))

  (defun-inline construct_singleton (SINGLETON_HASH_TO_CURRY METADATA_LAYER_HASH new_metadata new_metadata_updater new_inner_puz)
    (puzzle-hash-of-curried-function SINGLETON_HASH_TO_CURRY
                                    (puzzle-hash-of-curried-function METADATA_LAYER_HASH
                                                                     new_inner_puz
                                                                     new_metadata_updater
                                                                     (sha256tree1 new_metadata)
                                    )
    )
  )

  (defun verify_proofs (new_root VALUES_TO_PROVE proofs_of_inclusion)
    (if proofs_of_inclusion
        (assert (= new_root (simplify_merkle_proof (f VALUES_TO_PROVE) (f proofs_of_inclusion)))
          ; then
          (verify_proofs new_root (r VALUES_TO_PROVE) (r proofs_of_inclusion))
        )
        1
    )
  )

  (defun main
    (
      SINGLETON_HASHES_TO_CURRY
      METADATA_LAYER_HASHES
      VALUES_TO_PROVE
      proofs_of_inclusion
      new_metadatas
      new_metadata_updaters
      new_inner_puzs
      conditions
    )

    (if SINGLETON_HASHES_TO_CURRY
      (assert (verify_proofs (f (f new_metadatas)) (f VALUES_TO_PROVE) (f proofs_of_inclusion))
        ; then
        (main
          (r SINGLETON_HASHES_TO_CURRY)
          (r METADATA_LAYER_HASHES)
          (r VALUES_TO_PROVE)
          (r proofs_of_inclusion)
          (r new_metadatas)
          (r new_metadata_updaters)
          (r new_inner_puzs)
          (c
            (list
              ASSERT_PUZZLE_ANNOUNCEMENT
              (sha256
                (construct_singleton (f SINGLETON_HASHES_TO_CURRY) (f METADATA_LAYER_HASHES) (f new_metadatas) (f new_metadata_updaters) (f new_inner_puzs))
                '$'
              )
            )
            conditions
          )
        )
      )
      conditions
    )
  )

  (main
    SINGLETON_HASHES_TO_CURRY
    METADATA_LAYER_HASHES
    VALUES_TO_PROVE
    proofs_of_inclusion
    new_metadatas
    new_metadata_updaters
    new_inner_puzs
    (a INNER_PUZZLE inner_solution)
  )
)